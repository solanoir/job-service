<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Developer Search</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>

  <!-- Login Form -->
  <div id="loginContainer" class="login-container">
    <div class="login-form">
      <h2>Login</h2>
      <input type="text" id="loginId" placeholder="ID" />
      <input type="password" id="loginPassword" placeholder="Password" />
      <button id="loginBtn">Login</button>
      <div id="loginError" class="error-message" style="display:none;"></div>
    </div>
  </div>

  <!-- Main App -->
  <div id="mainContainer" class="main-container" style="display:none;">
    <div class="left-panel">
      <h1>Developer Knowledge Search</h1>

      <!-- Collation Select -->
      <div class="select-group">
        <label for="collationSelect">Collation:</label>
        <select id="collationSelect" multiple>
        </select>
      </div>

      <!-- Type Select -->
      <div class="select-group">
        <label for="typeSelect">Type:</label>
        <select id="typeSelect" multiple>
        </select>
      </div>


    </div>

    <div class="right-panel">
      <!-- Search Box -->
      <div class="search-area">
        <input type="text" id="searchInput" placeholder="Type a keyword..." />
        <button id="searchBtn">Search</button>
      </div>
      <!-- Active Filters -->
      <div id="activeFilters" class="active-filters"></div>
      <!-- Search Term Display -->
      <div id="searchTermDisplay" class="search-term-display" style="display:none;"></div>
      <!-- Results -->
      <div id="results" class="results"></div>
      <div id="error" class="error-message" style="display:none;color:#b00020;margin-top:8px;"></div>
    </div>
  </div>

  <script>
    let data = [];

    const collationAvatars = {
      'Full stack': 'ðŸ› ï¸',
      'shopify': 'ðŸ›’',
      'scraping': 'ðŸ•·ï¸',
      'game': 'ðŸŽ®',
      'Python': 'ðŸ',
      'JavaScript (JS)': 'ðŸŸ¨',
      'Node.js': 'âš¡',
      'TypeScript (TS)': 'ðŸ”µ',
      'C++': 'ðŸ’ ',
      'C#': 'ðŸŸ£',
      'Java': 'â˜•',
      'Go (Golang)': 'ðŸ’™',
      'Rust': 'ðŸ¦€',
      'Swift': 'ðŸ',
      'PHP': 'ðŸ’œ',
      'HTML': 'ðŸ“„',
      'CSS': 'ðŸŽ¨',
      'SQL': 'ðŸ—„ï¸',
      'PostgreSQL': 'ðŸ§±',
      'MySQL': 'ðŸ§Š'
    };

    // Login
    document.getElementById('loginBtn').addEventListener('click', () => {
      const id = document.getElementById('loginId').value;
      const password = document.getElementById('loginPassword').value;
      const errorBox = document.getElementById('loginError');
      if (id === 'admin' && password === 'admin') {
        document.getElementById('loginContainer').style.display = 'none';
        document.getElementById('mainContainer').style.display = 'flex';
        fetchData();
      } else {
        errorBox.style.display = 'block';
        errorBox.textContent = 'Invalid ID or password';
      }
    });

    // Load JSON (relative file)
    const errorBox = document.getElementById('error');
    function showError(msg) {
      console.error(msg);
      errorBox.style.display = 'block';
      errorBox.textContent = msg;
    }

    if (location.protocol === 'file:') {
      // When opening an HTML file directly in the browser (file://), fetch will often fail due to CORS/file restrictions.
      showError('Warning: opening via file:// prevents loading JSON. Run a local server (see README) or click "Run a Local Server" below.');
    }

    function fetchData() {
      // Show a temporary "loading" state
      document.getElementById('results').innerHTML = '<p class="loading">Loading...</p>';

      fetch('data.json')
        .then(res => {
          if (!res.ok) throw new Error('HTTP error ' + res.status);          
          return res.json();
        })
        .then(json => {
          console.log(json);
          
          data = json;
          
          populateSelects();
          updateActiveFilters();
          // Show initial results (all items) after data loads
          search();
          errorBox.style.display = 'none';
        })
        .catch(err => {
          showError('Failed to load data.json: ' + err.message);
        });
    }

    // Populate selects
    function populateSelects() {
      const collationSelect = document.getElementById('collationSelect');
      const typeSelect = document.getElementById('typeSelect');

      const allCollations = Object.keys(collationAvatars);
      const uniqueTypes = [...new Set(data.map(item => item.type))];

      allCollations.forEach(collation => {
        const option = document.createElement('option');
        option.value = collation;
        option.textContent = (collationAvatars[collation] || 'ðŸ“') + ' ' + collation;
        collationSelect.appendChild(option);
      });

      uniqueTypes.forEach(type => {
        const option = document.createElement('option');
        option.value = type;
        option.textContent = type;
        typeSelect.appendChild(option);
      });
    }

    // Search function - tokenized (one or more words)
    function search() {
      const keyword = document.getElementById("searchInput").value.trim().toLowerCase();
      const selectedCollations = Array.from(document.getElementById("collationSelect").selectedOptions).map(o => o.value);
      const selectedTypes = Array.from(document.getElementById("typeSelect").selectedOptions).map(o => o.value);
      const resultsBox = document.getElementById("results");

      // Add search term display
      const searchTermDisplay = document.getElementById("searchTermDisplay");
      if (keyword) {
        searchTermDisplay.textContent = `Search results for: "${keyword}"`;
        searchTermDisplay.style.display = "block";
      } else {
        searchTermDisplay.style.display = "none";
      }

      resultsBox.innerHTML = "";

      // Split into tokens and require that every token is present in content (AND semantics)
      const tokens = keyword.length ? keyword.split(/\s+/).filter(Boolean) : [];

      const filtered = data.filter(item => {
        const textLower = (item.collation + ' ' + item.type + ' ' + item.content).toLowerCase();
        const matchKeyword = tokens.length === 0 || tokens.every(t => textLower.includes(t));
        const matchCollation = selectedCollations.length === 0 || selectedCollations.includes(item.collation);
        const matchType = selectedTypes.length === 0 || selectedTypes.includes(item.type);

        console.log(item);
        

        return matchKeyword && matchCollation && matchType;
      });

      if (filtered.length === 0) {
        resultsBox.innerHTML = "<p class='no-results'>No matching results found.</p>";
        return;
      }

      filtered.forEach(item => {
        const div = document.createElement("div");
        div.className = "result-item";
        const emoji = collationAvatars[item.collation] || '';
        div.innerHTML = `<strong>Collation:</strong> ${emoji} ${item.collation}<br><strong>Type:</strong> ${item.type}<br><strong>Content:</strong> `;
        div.appendChild(createHighlightNode(item.content, keyword));
        resultsBox.appendChild(div);
      });
    }

    // Button click â†’ search
    document.getElementById("searchBtn").addEventListener("click", search);

    // ENTER key â†’ search
    document.getElementById("searchInput").addEventListener("keydown", function (e) {
      if (e.key === "Enter") search();
    });

    // Live search while typing for immediate feedback
    document.getElementById("searchInput").addEventListener("input", function (e) {
      search();
    });

    // Update active filters display
    function updateActiveFilters() {
      const activeFiltersDiv = document.getElementById("activeFilters");
      activeFiltersDiv.innerHTML = "";

      const selectedCollations = Array.from(document.getElementById("collationSelect").selectedOptions).map(o => o.value);
      const selectedTypes = Array.from(document.getElementById("typeSelect").selectedOptions).map(o => o.value);

      const allSelected = [
        ...selectedCollations.map(c => ({ type: 'collation', value: c })),
        ...selectedTypes.map(t => ({ type: 'type', value: t }))
      ];

      if (allSelected.length === 0) {
        activeFiltersDiv.style.display = "none";
        return;
      }

      activeFiltersDiv.style.display = "block";

      allSelected.forEach(item => {
        const tag = document.createElement("span");
        tag.className = "filter-tag";
        const emoji = item.type === 'collation' ? (collationAvatars[item.value] || '') : '';
        tag.innerHTML = `${emoji} ${item.type}: ${item.value} <button onclick="removeFilter('${item.type}', '${item.value}')">Ã—</button>`;
        activeFiltersDiv.appendChild(tag);
      });
    }

    function removeFilter(filterType, value) {
      const select = document.getElementById(filterType + "Select");
      const option = Array.from(select.options).find(o => o.value === value);
      if (option) {
        option.selected = false;
      }
      updateActiveFilters();
      search();
    }

    // Select change â†’ update filters and search
    document.getElementById("collationSelect").addEventListener("change", () => {
      updateActiveFilters();
      search();
    });
    document.getElementById("typeSelect").addEventListener("change", () => {
      updateActiveFilters();
      search();
    });

    // Utility function to safely escape regex chars in user input
    function escapeRegExp(s) {
      return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    // Create a DocumentFragment with highlighted matches for the given search (case-insensitive)
    function createHighlightNode(text, search) {
      const frag = document.createDocumentFragment();
      if (!search || !search.trim()) {
        frag.appendChild(document.createTextNode(text));
        return frag;
      }

      const tokens = search.trim().split(/\s+/).filter(Boolean);
      if (tokens.length === 0) {
        frag.appendChild(document.createTextNode(text));
        return frag;
      }

      const pattern = tokens.map(escapeRegExp).join('|');
      const regex = new RegExp(pattern, 'gi');
      let lastIndex = 0;
      let m;
      while ((m = regex.exec(text)) !== null) {
        const start = m.index;
        if (start > lastIndex) {
          frag.appendChild(document.createTextNode(text.slice(lastIndex, start)));
        }
        const span = document.createElement('span');
        span.className = 'highlight';
        span.textContent = text.slice(start, regex.lastIndex);
        frag.appendChild(span);
        lastIndex = regex.lastIndex;
      }
      if (lastIndex < text.length) {
        frag.appendChild(document.createTextNode(text.slice(lastIndex)));
      }
      return frag;
    }

  </script>

</body>

</html>